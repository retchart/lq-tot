/**
	******************************************************************************
 * Copyright(c) 2019 Tsinghua University
 * All rights reserved
 *
 * ide1162.v: ide1162 readout and test.
 * author: liulixing, liulx18@mails.tsinghua.edu.cn
 * date: 2019.12.31
	******************************************************************************
*/

module ide1162_trigger
#(
	parameter CLK_FRE = 200        //clock frequency(Mhz)
)
(
	input				sys_clk,
	input				rst_n,

	input				enable,
	input[31:0]			din,
	input[7:0]			jitter_time,
	output reg			trigger,
	output reg[31:0]	trigger_pos
	);

// trigger state
localparam	IDLE		= 2'b00;
localparam	TRIGGER		= 2'b01;
localparam	WAIT		= 2'b10;
localparam	END			= 2'b11;

// trigger jitter period.
localparam	TRIGGER_JITTER_CYCLE	= 8'd100;	// All trigger valid in 1000nS
// jitter time cycle table. unit is 0.1us. The range is 0.1 - 1.6us.
// System clock is 200Mhz!!!
reg[8:0] jitter_time_cycle[15:0];
always@(posedge sys_clk)
begin
	jitter_time_cycle[0]  <= 9'd19;
	jitter_time_cycle[1]  <= 9'd29;
	jitter_time_cycle[2]  <= 9'd59;
	jitter_time_cycle[3]  <= 9'd79;
	jitter_time_cycle[4]  <= 9'd99;
	jitter_time_cycle[5]  <= 9'd119;
	jitter_time_cycle[6]  <= 9'd139;
	jitter_time_cycle[7]  <= 9'd159;
	jitter_time_cycle[8]  <= 9'd179;
	jitter_time_cycle[9]  <= 9'd199;
	jitter_time_cycle[10] <= 9'd219;
	jitter_time_cycle[11] <= 9'd239;
	jitter_time_cycle[12] <= 9'd259;
	jitter_time_cycle[13] <= 9'd279;
	jitter_time_cycle[14] <= 9'd299;
	jitter_time_cycle[15] <= 9'd319;
end

// din buffer
reg[31:0] din_buf0;
reg[31:0] din_buf1;
always@(posedge sys_clk or negedge rst_n)
begin
	if(rst_n == 1'b0) begin
		din_buf0 <= 32'd0;
		din_buf1 <= 32'd0;
	end
	else begin
		din_buf0 <= din;
		din_buf1 <= din_buf0;
	end
end

// posedge of din detect.
 wire[31:0] din_posedge;
assign din_posedge[0] = (~din_buf1[0]) && (din_buf0[0]);
assign din_posedge[1] = (~din_buf1[1]) && (din_buf0[1]);
assign din_posedge[2] = (~din_buf1[2]) && (din_buf0[2]);
assign din_posedge[3] = (~din_buf1[3]) && (din_buf0[3]);
assign din_posedge[4] = (~din_buf1[4]) && (din_buf0[4]);
assign din_posedge[5] = (~din_buf1[5]) && (din_buf0[5]);
assign din_posedge[6] = (~din_buf1[6]) && (din_buf0[6]);
assign din_posedge[7] = (~din_buf1[7]) && (din_buf0[7]);
assign din_posedge[8] = (~din_buf1[8]) && (din_buf0[8]);
assign din_posedge[9] = (~din_buf1[9]) && (din_buf0[9]);
assign din_posedge[10] = (~din_buf1[10]) && (din_buf0[10]);
assign din_posedge[11] = (~din_buf1[11]) && (din_buf0[11]);
assign din_posedge[12] = (~din_buf1[12]) && (din_buf0[12]);
assign din_posedge[13] = (~din_buf1[13]) && (din_buf0[13]);
assign din_posedge[14] = (~din_buf1[14]) && (din_buf0[14]);
assign din_posedge[15] = (~din_buf1[15]) && (din_buf0[15]);
assign din_posedge[16] = (~din_buf1[16]) && (din_buf0[16]);
assign din_posedge[17] = (~din_buf1[17]) && (din_buf0[17]);
assign din_posedge[18] = (~din_buf1[18]) && (din_buf0[18]);
assign din_posedge[19] = (~din_buf1[19]) && (din_buf0[19]);
assign din_posedge[20] = (~din_buf1[20]) && (din_buf0[20]);
assign din_posedge[21] = (~din_buf1[21]) && (din_buf0[21]);
assign din_posedge[22] = (~din_buf1[22]) && (din_buf0[22]);
assign din_posedge[23] = (~din_buf1[23]) && (din_buf0[23]);
assign din_posedge[24] = (~din_buf1[24]) && (din_buf0[24]);
assign din_posedge[25] = (~din_buf1[25]) && (din_buf0[25]);
assign din_posedge[26] = (~din_buf1[26]) && (din_buf0[26]);
assign din_posedge[27] = (~din_buf1[27]) && (din_buf0[27]);
assign din_posedge[28] = (~din_buf1[28]) && (din_buf0[28]);
assign din_posedge[29] = (~din_buf1[29]) && (din_buf0[29]);
assign din_posedge[30] = (~din_buf1[30]) && (din_buf0[30]);
assign din_posedge[31] = (~din_buf1[31]) && (din_buf0[31]);

// trigger
reg[1:0] state;
 reg[15:0] state_clk_cnt;
reg[31:0] trigger_pos_buf;
always@(posedge sys_clk or negedge rst_n)
begin
	if(rst_n == 1'b0) begin
		state <= IDLE;
		trigger <= 1'b0;
		state_clk_cnt <= 16'd0;
		trigger_pos_buf <= 32'b0;
		trigger_pos <= 32'b0;
	end
	else begin
		case(state)
			IDLE: begin
				state_clk_cnt <= 16'd0;
				if(din_posedge > 1'b0 && enable) begin
					trigger <= 1'b1;
					trigger_pos_buf <= din_posedge;
					state <= TRIGGER;
				end
				else begin
					trigger <= 1'b0;
				end
			end
			TRIGGER:begin
				// If another wire's signal trigger
				if(din_posedge > 1'b0) begin
					// state_clk_cnt <= 16'd0;
					trigger_pos_buf <= trigger_pos_buf | din_posedge;
				end
				else begin
					// A typical MWPC signal is about 200nS. 
					// So, trigger delay about 50 sys_clk(200MHz, 250nS).
					// if(state_clk_cnt == TRIGGER_JITTER_CYCLE - 1'b1) begin
					//     trigger_pos <= trigger_pos_buf;
					//     trigger <= 1'b0;
					//     state <= END;
					//     state_clk_cnt <= 16'd0;
					// end
					if(state_clk_cnt == jitter_time_cycle[jitter_time]) begin
						trigger_pos <= trigger_pos_buf;
						trigger <= 1'b0;
						state <= END;
						state_clk_cnt <= 16'd0;
					end
					else begin
						state_clk_cnt <= state_clk_cnt + 1'b1;
					end
				end
			end
			END: begin
				trigger_pos_buf <= 32'b0;
				state <= IDLE;
				state_clk_cnt <= 16'd0;	
			end
			default: begin
				trigger_pos_buf <= 32'b0;
				state <= IDLE;
				state_clk_cnt <= 16'd0;	
			end

		endcase
	end
end
// analyze trigger
endmodule
